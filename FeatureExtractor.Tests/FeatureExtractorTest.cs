using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections.Generic;

namespace FeatureExtractor.Tests
{
    [TestClass]
    public class FeatureExtractorTest
    {
        [TestMethod]
        public void TestExtractWithContextAndOneSimpleScenario()
        {
            // Arrange
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD_044", new Tuple<string, string>("", "  Contexte: Étant donné un interpréteur de script Scénario: Changement de table Étant donné un matériel Et la configuration définissant la table 7 Lorsque j'appelle le mot clef changeTable 7 Alors le script retourne OK"));
            
            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            Assert.AreEqual("Étant donné un interpréteur de script", extractedRequirements["ESD_044"].m_strContext);
            Assert.AreEqual(1, extractedRequirements["ESD_044"].m_Scenarios.Count);
            bool bFound = false;
            for (int i = 0; i < extractedRequirements["ESD_044"].m_Scenarios.Count; i++)
            {
                if (extractedRequirements["ESD_044"].m_Scenarios[i].m_strSteps == "Étant donné un matériel Et la configuration définissant la table 7 Lorsque j'appelle le mot clef changeTable 7 Alors le script retourne OK" &&
                    extractedRequirements["ESD_044"].m_Scenarios[i].m_strTitle == "Changement de table")
                {
                    bFound = true;
                }
            }
            Assert.AreEqual(true, bFound);

        }

        [TestMethod]
        public void TestExtractIssue1()
        {
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-001", new Tuple<string, string>("","Description La configuration matérielle de l’application permet de connaître le contexte dans lequel l’utilisateur veut utiliser l’application. Il doit être en mesure de paramétrer : Le type de détecteur, Le type de générateur, Le type de RTC, Le type de carte d'acquisition, La demande de reset du RTC, La demande de reset du détecteur ou pas au démarrage de TeTriS, La demande de rafraîchissement de l’interface avec les paramètres du détecteur, Le nom du port série pour le RTC, Le nom du port série pour le générateur de rayons X. Accès à la fonctionnalité depuis un profil Conditions Lancer TeTriS Résultats attendus Une fenêtre de sélection de profil s’affiche avec les profils présents dans le répertoire courant de l’application. Un bouton   permet de sélectionner un autre répertoire afin de sélectionner d’autres profils sur un autre répertoire. Une fois le répertoire choisi, la fenêtre se met à jour avec les nouveaux profils trouvés et efface les profils de l’ancien répertoire.  Accès à la fonctionnalité depuis le fichier TeTriS_Configuration.ini Conditions Chaque répertoire de profil doit contenir un fichier TeTriS_Configuration.ini. Résultats attendus Si ce fichier n'existe pas dans le répertoire de profil, l’application ne peut pas démarrer et une boite de dialogue s’ouvre. Elle prévient l’utilisateur que l’application ne peut démarrer sans ce fichier.        Si le fichier existe : Lors du lancement de l'application, un contrôle est fait sur les choix hardware du profil, afin de vérifier la concordance du matériel choisi et d’éviter que l’application ne démarre avec une configuration qui n’a pas de sens.   Spécifications exécutables  Scénario: Vérification du RTC Port pour un RTC NO     Etant donné le champ Active RTC defini a NO     Lorsque je verifie la configuration RTC     Alors TeTriS ne verifie pas le champ RTC Port  Scénario: Vérification du RTC Port pour un RTC soft ou hard     Etant donné le champ Active RTC defini a un type de RTC hard ou soft         Et le champ RTC Port <etat>     Lorsque je verifie la configuration RTC     Alors j’ai la boite de dialogue d’erreur IDS_ERR_RTC_PORT_CONFIG         Et TeTriS ne se lance pas Exemple:     | etat       |     | inexistant |     | vide       |    IDS_ERR_RTC_PORT_CONFIG  Erreur de configuration de TeTriS : RTC port non défini dans le fichier  TeTriS Configuration Error : there is no RTC port configuration in the file       Cette vérification du matériel se fait via la lecture du fichier de configuration «HardwareConfigurationTable_Default.ini ». En effet, ce dernier liste toutes les combinaisons de hardware autorisées possibles, il est analysé au lancement de l’application afin de continuer ou de bloquer le démarrage. Si les champs ne sont pas renseignés ou sont commentés, la valeur par défaut est « NO » (pas de matériel de connecté). Si la configuration matérielle n'existe pas, le lancement de l'application est arrêté et une boite de dialogue s'ouvre avec un message rappelant à l'utilisateur sa configuration hardware, et que celle-ci n’est pas correcte.    "));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            Assert.AreEqual("", extractedRequirements["ESD-TXL-TeTriS-001"].m_strContext);
            Assert.AreEqual(2, extractedRequirements["ESD-TXL-TeTriS-001"].m_Scenarios.Count);
            
            Assert.AreEqual("Etant donné le champ Active RTC defini a NO Lorsque je verifie la configuration RTC Alors TeTriS ne verifie pas le champ RTC Port", extractedRequirements["ESD-TXL-TeTriS-001"].m_Scenarios[0].m_strSteps);
            Assert.AreEqual("Vérification du RTC Port pour un RTC NO", extractedRequirements["ESD-TXL-TeTriS-001"].m_Scenarios[0].m_strTitle);

            Assert.AreEqual("Etant donné le champ Active RTC defini a un type de RTC hard ou soft Et le champ RTC Port <etat> Lorsque je verifie la configuration RTC Alors j’ai la boite de dialogue d’erreur IDS_ERR_RTC_PORT_CONFIG Et TeTriS ne se lance pas Exemple: | etat | | inexistant | | vide |", extractedRequirements["ESD-TXL-TeTriS-001"].m_Scenarios[1].m_strSteps);
            Assert.AreEqual("Vérification du RTC Port pour un RTC soft ou hard", extractedRequirements["ESD-TXL-TeTriS-001"].m_Scenarios[1].m_strTitle);
        }

        [TestMethod]
        public void TestExtractIssue2()
        {
            // Arrange
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD_005", new Tuple<string, string>("","Description Ce paragraphe décrit comment l’utilisateur est informé des événements qui ont lieu au cours de l’utilisation de l’application. Si TeTriS est lancé en mode « externalisation des messages », alors ces messages seront redirigés vers l’application de supervision située sur un poste accessible via le réseau (car le mécanisme de transfert de messages utilise le protocole réseau TCP/IP).   Les messages peuvent apparaître sous plusieurs formes : les messages dans la fenêtre de sortie standard,   On retrouve dans cette vue des messages provenant de tous les composants qui veulent envoyer à l’utilisateur des messages non bloquants : l’interface homme machine (IHM), l’interpréteur de script TCL, les messages remontés par le module de la carte d’acquisition, les messages remontés par le module du détecteur, les messages remontés par le module de gestion des périphériques DIO.  les messages dans la fenêtre de sortie hardware,   La partie haute de cette vue reçoit des messages d’alerte ou d’information provenant des composants RTC. Ces messages RTC sont asynchrones. La partie basse de cette vue reçoit des messages asynchrones du générateur de rayons X. Les buffers utilisés pour l’affichage des données pour ces trois fenêtres sont des buffers tournant de 10000000 octets. C'est-à-dire que si l’on atteint la limite alors lors de la prochaine écriture les premiers octets seront supprimés pour être remplacés par les nouveaux. Toutes les traces de tous les logs seront terminées par le caractére de retour chariot ‘\n’.   les boîtes de messages bloquantes d’information, d’avertissement et d’erreur, suivant la criticité du message,          Remarque : Dans le cas où TeTriS a été lancé en mode « Externalisation des messages », les messages bloquants d’information seront automatiquement validés par TETRIS afin d’être externalisés, afin de ne pas bloquer le traitement. Ceci n’a aucune incidence sur la suite des traitements.   les boîtes de dialogues bloquantes de décision, Elles sont utilisées pour solliciter un choix de la part de l’utilisateur. Ces fenêtres contiennent souvent trois boutons  OUI  NON  ANNULER . Le choix de l’utilisateur modifie la suite du traitement.    les boîtes de dialogue de saisie, Ce sont des fenêtres invitant l’utilisateur à saisir des données qui seront utilisées par TETRIS pour effectuer le traitement demandé.  Exemple : Fenêtre de sélection de fichier  les fichiers de données (fichiers de trace), une boîte de message avec les boutons « YES » / « NO », une boîte d’attente avec bouton « OK », une boîte d’attente avec bouton « OK » et une barre d’attente. Messages extérieurs TETRIS utilise plusieurs applications tierces, dont certaines peuvent afficher des messages bloquants. C’est notamment le cas de l’utilitaire IniTestDlg.exe, lancé depuis un script TCL, il permet d’afficher une boite de dialogues, sollicitant une action de l’utilisateur.  Tout exécutable peut potentiellement être lancé depuis un script TCL. Les messages provenant de ces applications externes sont mis dans la catégorie de messages extérieurs. Accès à la fonctionnalité depuis le fichier TeTriS_Configuration.ini Conditions Ce fichier permet notamment : Le paramétrage d’un fichier de traces (optionnel) : Fichier de trace de tous les messages de sortie de l'application ainsi que ceux provenant du détecteur. Fichier de trace des messages provenant du RTC Fichier de trace des messages provenant du Générateur X Fichier de trace des messages provenant du Serveur   Le paramétrage de l’affichage de l’heure au début de chaque message des fenêtres de sortie (optionnel). Les fichiers de trace doivent pouvoir être consultables durant l’exécution de TeTriS, c'est-à-dire que l’on doit pouvoir les ouvrir ou les copier. Résultats attendus Si les chemins vers les fichiers de trace sont valides, alors tout le contenu de la fenêtre qui lui est associée est recopié dans ce fichier, à l’emplacement donné par l’utilisateur. Il est alors possible de les ouvrir ou de les copier, pendant l’exécution de TeTriS. Si les chemins vers les fichiers de trace ne sont pas valides, alors aucun fichier n’est créé.  Si le paramètre Clock est demandé, alors l’heure d’affichage du message sera affichée avant chaque message. Accès à la fonctionnalité depuis un script TCL Conditions Syntaxe : showYesNoMsg message   showMsgWait  message    showMsgTime message  timeout Résumé : Ces mots clefs permettent d’afficher différents types de boîtes de message.  Spécifications exécutables  Contexte:     Etant donné un interpreteur TCL     Etant donné l’IHM de TeTriS  Scénario: Demande d’affichage d’une boite de dialogue avec time out     Lorsque un script execute la commande showMsgTime \"Ceci est un message avec time out\" 25     Alors une boite de dialogue modale avec le texte \"Ceci est un message avec time out\" est affichée     Et le script retourne TCL_OK après 25 s     Et la boîte modale est fermée   Scénario: Demande d’affichage d’une boite de dialogue avec time out non décimal     Lorsque un script execute la commande showMsgTime \"Ceci est un message avec time out\" 25X000      Alors il n’y a pas de boîte modale affichée     Et j’ai la trace d’erreur numero IDS_TCL_ERR_SHOW_MSG_TIME_WRONG_ARG.     Et le script retourne TCL_KO    Résultats attendus showYesNoMsg permet d’afficher une boîte de message avec le choix entre YES et NO.   showMsgWait permet d’afficher  une boîte de message bloquante avec un seul choix pour fermer la boîte (OK)   showMsgTime permet d’afficher une boîte de message avec un timeout qui tient lieu de compte à rebours.    A la fin du compte à rebours la boîte est fermée automatiquement."));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            Assert.AreEqual(2, extractedRequirements["ESD_005"].m_Scenarios.Count);
            
            Assert.AreEqual("Etant donné un interpreteur TCL Etant donné l’IHM de TeTriS", extractedRequirements["ESD_005"].m_strContext);
            
            Assert.AreEqual("Lorsque un script execute la commande showMsgTime \"Ceci est un message avec time out\" 25 Alors une boite de dialogue modale avec le texte \"Ceci est un message avec time out\" est affichée Et le script retourne TCL_OK après 25 s Et la boîte modale est fermée", extractedRequirements["ESD_005"].m_Scenarios[0].m_strSteps);
            Assert.AreEqual("Demande d’affichage d’une boite de dialogue avec time out", extractedRequirements["ESD_005"].m_Scenarios[0].m_strTitle);
            
            Assert.AreEqual("Lorsque un script execute la commande showMsgTime \"Ceci est un message avec time out\" 25X000 Alors il n’y a pas de boîte modale affichée Et j’ai la trace d’erreur numero IDS_TCL_ERR_SHOW_MSG_TIME_WRONG_ARG. Et le script retourne TCL_KO", extractedRequirements["ESD_005"].m_Scenarios[1].m_strSteps);
            Assert.AreEqual("Demande d’affichage d’une boite de dialogue avec time out non décimal", extractedRequirements["ESD_005"].m_Scenarios[1].m_strTitle);
                

        }

        [TestMethod]
        public void TestExtractIssue4()
        {
            // Arrange
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-008", new Tuple<string, string>("Lancement de l’application [p.87]", "Description L’application TeTriS peut être lancée de plusieurs manières : Depuis le fichier exécutable directement (donc sans ligne de commande) En ligne de commande (de plusieurs façons).  Le fichier exécutable doit être contenu dans le répertoire de package de tests asterix. Lors du démarrage de TeTriS une fenêtre indique les différentes étapes d’initialisation : Vérification de la configuration de la carte réseau (facultatif) Connexion avec la carte d’acquisition Connexion avec le RTC Connexion avec le générateur Connexion avec le détecteur Lancement du script tcl defaultstartup.tcl Rafraichissement de l’interface homme machine  Spécifications exécutables  Scénario: Vérification de la configuration de la carte réseau      Etant donné les données Ethernet correctement définies dans la configuration TeTriS         Et la carte reseau \"Ethernet Board Name\" avec une adresse IP <statut> de celle definie par Ethernet Board IP          Et un utilisateur avec les droits <droits>     Lorsque TeTriS initialise le materiel     Alors l’adresse IP de la carte est <etat>         Et j’ai la boite d’initialisation hardware avec l’information Ethernet board setting : <resultat> Exemples : | statut     | droits             | etat         | resultat          | | differente | administrateur     | modifiee     | OK (modified)     | | differente | non administrateur | non modifiee | error             | | identique  | administrateur     | non modifiee | OK (not modified) | | identique  | non administrateur | non modifiee | OK (not modified) |  Scénario: Vérification de la configuration de la carte réseau avec configuration insuffisante     Etant donné les données Ethernet dans la configuration TeTriS <etat>     Lorsque TeTriS initialise le materiel     Alors j’ai la boite d’initialisation hardware avec l’information Ethernet board setting : <resultat> Exemples : | etat         | resultat  | | inexistantes | not done  | | vides        | not done  | | erronées     | error     |   Avant la connexion avec le générateur, si un module DIO est présent TeTriS teste si la porte du générateur est fermée. Si elle est ouverte affichage de la trace d’information dans la sortie générateur IDS_TXL_GENERATOR_DOOR_OPENED.  IDS_TXL_GENERATOR_DOOR_OPENED  ATTENTION : La porte du générateur est ouverte  XGenerator door is not closed MM :SS ». HH représente l’heure courante sur 24 heures, MM représente les minutes courantes, SS représente les secondes courantes. Exemple :      Si l’initialisation échoue un message modal récapitule l’état de l’initialisation sous forme de  « Acquisition board\\t  : statusRTC\\t\\t  : status X-ray generator\\t  : status Detector\\t\\t  : status »  Si la configuration du port du module DIO USB échoue le message IDS_DIO_CONFIGURE_PORT_FAILED est affiché et TeTriS sort avec le code d’erreur 1  IDS_DIO_CONFIGURE_PORT_FAILED  “Echec de configuration du port du module USB DIO”  \"Cannot configure port for USBDIO module.\"      Le statut est  « Disable » si le matériel correspondant est defini à NO dans le fichier de configuration.  Exemple   Accès à la fonctionnalité sans ligne de commande Conditions Il s’agit d’un double-clic sur l’application ou le lancement de l’application depuis une application externe sans ligne de commande. Résultats attendus Il conduit à l’exécution simple de l’application.  Le titre de l’application est correctement renseigné en fonction du profil demandé. Les positions des fenêtres sont celles mémorisées dans le fichier TeTriS_Registry.ini. Accès à la fonctionnalité avec une ligne de commande Conditions L’application peut-être exécutée depuis un raccourci, un fichier bat, une application extérieure. La ligne de commande est composée de plusieurs paramètres et options : Nom du profil Nom du script à exécuter (optionnel) Exécution « cachée » (optionnel : défaut = pas caché). Option d’externalisation des messages (voir paragraphe correspondant) Obtention de la version (-v)  Lors du lancement de TeTriS via une ligne de commande sans l’option extmsg, la boîte de dialogue apparaissant lors d’une erreur d’exécution de script TCL n’apparait pas. Les informations qu’elle contient seront affichées dans la fenêtre de sortie standard. Lors du lancement de TeTriS via une ligne de commande avec l’option -v, aucune autre commande ne doit être présente. Si un paramètre est erroné il est ignoré et aucune trace ne l’indique à l’opérateur. Par exemple si l’opérateur saisi –extmag 7400, TeTriS se lancera en mode mono poste. Résultats attendus Le titre de l’application est correctement renseigné en fonction du profil demandé. Les positions des fenêtres sont celles mémorisées dans le fichier TeTriS_Registry.ini.  Suivant le cas : Nom du profil seulement : TeTriS va être lancé avec le profil correspondant et va se mettre en attente d’une utilisation manuelle, Nom du script à exécuter : TeTriS va se lancer, exécuter le script et se fermer automatiquement sans demander une intervention de l’utilisateur, Exécution « cachée » : TeTriS sera exécuté en mode invisible. Obtention de la version : Le paramètre v affichera le numéro court de la version de Tetris, exemple pour la version 61542913AX, AX sera affiché. L’appel  à ce paramètre affichera la version de Tetris dans la console, puis  Tetris se fermera.  Si une erreur survient lors du lancement du à la ligne de commande, une boîte de dialogue modale en informe l’opérateur.  Message d’erreur Si le script n’existe pas : \"TeTriS error : the script script does not exist\" où script est le nom du script avec son chemin d’accès Si le profil n’existe pas : \"TeTriS error : the profil profil does not exist\"où profil est le nom du profil utilisé Si l’usage est incorrect : \"TETRIS usage : tetris.exe [-p profil_utilisateur [ [-i script] [-hide] [-extmsg serverport] ] ] [-v]\""));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            Assert.AreEqual(2, extractedRequirements["ESD-TXL-TeTriS-008"].m_Scenarios.Count);

            Assert.AreEqual("", extractedRequirements["ESD-TXL-TeTriS-008"].m_strContext);

            Assert.AreEqual("Etant donné les données Ethernet correctement définies dans la configuration TeTriS Et la carte reseau \"Ethernet Board Name\" avec une adresse IP <statut> de celle definie par Ethernet Board IP Et un utilisateur avec les droits <droits> Lorsque TeTriS initialise le materiel Alors l’adresse IP de la carte est <etat> Et j’ai la boite d’initialisation hardware avec l’information Ethernet board setting : <resultat> Exemples : | statut | droits | etat | resultat | | differente | administrateur | modifiee | OK (modified) | | differente | non administrateur | non modifiee | error | | identique | administrateur | non modifiee | OK (not modified) | | identique | non administrateur | non modifiee | OK (not modified) |", extractedRequirements["ESD-TXL-TeTriS-008"].m_Scenarios[0].m_strSteps);
            Assert.AreEqual("Vérification de la configuration de la carte réseau", extractedRequirements["ESD-TXL-TeTriS-008"].m_Scenarios[0].m_strTitle);

            Assert.AreEqual("Etant donné les données Ethernet dans la configuration TeTriS <etat> Lorsque TeTriS initialise le materiel Alors j’ai la boite d’initialisation hardware avec l’information Ethernet board setting : <resultat> Exemples : | etat | resultat | | inexistantes | not done | | vides | not done | | erronées | error |", extractedRequirements["ESD-TXL-TeTriS-008"].m_Scenarios[1].m_strSteps);
            Assert.AreEqual("Vérification de la configuration de la carte réseau avec configuration insuffisante", extractedRequirements["ESD-TXL-TeTriS-008"].m_Scenarios[1].m_strTitle);

        }

        [TestMethod]
        public void TestExtractIssue5()
        {
            // Arrange
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-081", new Tuple<string, string>("Envoi de commandes au détecteur [p.362]", "Contexte:     Etant donné un interpreteur TCL     Scénario: Envoi d’une commande au détecteur avec formatage de la réponse     Soit un détecteur de generation 3     Et la configuration detecteur definissant la commande : | en-tete | valeur | titre            | val_arg | format                      | | II      | 0x24   | Info Temperature | 0x600   | Temperature 0xs2 Range 0xu1 |     Et le detecteur renvoie comme reponse 00170102     Lorsque j’appelle le mot clef pxSend 0x24 0x600 true     Alors j’ai la trace d’information : II – Info Temperature\n      Et j’ai la reponse TCL {Temperature 0x0117 Range 0x02}     Et le script retourne TCL_OK  "));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            Assert.AreEqual(1, extractedRequirements["ESD-TXL-TeTriS-081"].m_Scenarios.Count);

            Assert.AreEqual("Etant donné un interpreteur TCL", extractedRequirements["ESD-TXL-TeTriS-081"].m_strContext);

            Assert.AreEqual("Soit un détecteur de generation 3 Et la configuration detecteur definissant la commande : | en-tete | valeur | titre | val_arg | format | | II | 0x24 | Info Temperature | 0x600 | Temperature 0xs2 Range 0xu1 | Et le detecteur renvoie comme reponse 00170102 Lorsque j’appelle le mot clef pxSend 0x24 0x600 true Alors j’ai la trace d’information : II – Info Temperature\n Et j’ai la reponse TCL {Temperature 0x0117 Range 0x02} Et le script retourne TCL_OK", extractedRequirements["ESD-TXL-TeTriS-081"].m_Scenarios[0].m_strSteps);
            Assert.AreEqual("Envoi d’une commande au détecteur avec formatage de la réponse", extractedRequirements["ESD-TXL-TeTriS-081"].m_Scenarios[0].m_strTitle);

        }

        [TestMethod]
        public void TestExtractIssue6()
        {
            // Arrange
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-034", new Tuple<string, string>("Ouverture d’un document de type FIT [p.153]",
                "Description Cette fonctionnalité permet d’ouvrir un document de type FIT dans l’application. Le fichier de FIT contient les paramètres du générateur pour une série de modes de fonctionnement. Les modes de fonctionnement sont classés en quatre catégories qui correspondent à des applications médicales en milieu hospitalier, contenant chacune des paramètres spécifiques (type FX). Chaque paramètre FX correspond à une dose de rayons X. Le titre de la fenêtre est affiché selon le patron suivant : titre [modifié] [lecture seule] Si le fichier est modifié alors [modifié] = ‘*’ Si le fichier ouvert est en lecture seule ou si le profil chargé est un profil de production alors [lecture seule] = ‘[Read Only]’ Si la fenêtre est maximisée, son titre se retrouve entre crochet à la suite du titre de TeTriS   Accès à la fonctionnalité depuis le menu « File -> Open » ou la barre d’outils standard Conditions Cette fonctionnalité est accessible avec ou sans générateur de présent. L’ouverture d’un fichier de type FIT via cette méthode revient à la méthode standard d’ouverture de document. Seule l’ouverture de fichier FIT PHILIPS est valide.   Specifications exécutables  Plan du Scénario: Ouverture depuis l’IHM d’un fichier FIT avec erreur de commentaire sur la première ligne     Etant donné la première ligne du fichier Fit1.fit ne contenant pas <ligne>     Et le reste du fichier contenant         | [Single/Serial Exposure]   |         | FX128= 1 1 1 70 100 60 100 |     Et un générateur <type>     Lorsque je charge ce fichier depuis l’IHM     Alors j’ai la boîte de dialogue en erreur avec le message: IDS_ERR_LOAD_FIT_FILE_WRONG_HEADER Exemples:     | ligne              | type                           |     | ; TeTriS LWDR file | Philips avec le protocole LWDR |     | ; XSTREAM FIT file | NO                             |     | ; XSTREAM FIT file | philips avec le protocole SDL    |  Résultats attendus Ouvre un fichier FIT Si le fichier est correct, le contenu est interprété pour être copié dans les champs du document FIT propre à l’application.  Si le profil est avec générateur – SIEMENS, alors le document n’est pas ouvert, et un message en informe l’utilisateur dans la fenêtre de messages Hardware. Accès à la fonctionnalité depuis un script TCL Conditions Cette fonctionnalité est accessible avec ou sans générateur de présent. L’utilisation de fichiers de type FIT n’a de sens qu’avec les générateurs de type PHILIPS. Syntaxe : loadFitFile chemin_fichier Résumé : Il attend un argument : le chemin vers le fichier FIT à ouvrir dans l’application.  Specifications executables  Contexte:     Soit un interpreteur TCL  Scénario: Chargement d’un fichier FIT avec un générateur NO     Etant donné un générateur NO     Lorsque j'appelle le mot clef loadFitFile fichier.fit     Alors j’ai la trace d’erreur numero IDS_ERR_TCL_NO_GENERATOR.     Et le script retourne TCL_KO  Scénario: Chargement d’un fichier FIT avec une mauvaise extension     Lorsque j'appelle le mot clef loadFitFile fichier.fut     Alors j’ai la trace d’erreur numero IDS_ERR_LOAD_FIT_FILE_WRONG_EXTENSION.     Et le script retourne TCL_KO  Plan du Scénario: Ouverture par mot clef TCL d’un fichier FIT avec erreur de commentaire sur la première ligne     Etant donné la première ligne du fichier Fit1.fit ne contenant pas <ligne>     Et le reste du fichier contenant :       | [Single/Serial Exposure]   |       | FX128= 1 1 1 70 100 60 100 |     Et un générateur <type>     Lorsque je charge ce fichier avec le mot clef loadFitFile Fit1.fit     Alors j’ai la trace [PB_T] loadFitFile Fit1.fit : IDS_ERR_LOAD_FIT_FILE_WRONG_HEADER     Et le script retourne TCL_KO Exemples:     | ligne              | type                           |     | ; TeTriS LWDR file | Philips avec le protocole LWDR |     | ; XSTREAM FIT file | NO                             |     | ; XSTREAM FIT file | Siemens                        |     | ; XSTREAM FIT file | philips avec le protole SDL    |   Résultats attendus Ouvre un fichier FIT et sortie de la fonction avec TCL_OK Si le fichier est correct, le contenu est interprété pour être copié dans les champs du document FIT propre à l’application. Si une erreur survient alors un message d’erreur est remonté via TclSetError et sortie de la fonction avec TCL_ERROR  Message d’information Si les paramètres du fichier sont incorrects : affichage du message IDS_ERR_FILL_GRID_LOAD_FIT_FILE.  Message d’erreur Si le nombre d’arguments n’est pas le bon : remontée par le TCL du message IDS_ERR_TCL_LOAD_FIT_FILE_INV_ARG_NUMBER. Si l’ouverture échoue : remontée par le TCL du message IDS_ERR_TCL_LOAD_FIT_FILE_ERR."));
           
            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            Assert.AreEqual(4, extractedRequirements["ESD-TXL-TeTriS-034"].m_Scenarios.Count);

            Assert.AreEqual("Soit un interpreteur TCL", extractedRequirements["ESD-TXL-TeTriS-034"].m_strContext);
        }

        [TestMethod]
        public void TestExtractIssue7()
        {
            // Arrange
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-034", new Tuple<string, string>("Ouverture d’un document de type FIT [p.153]",
                "Plan du Scénario: Ouverture depuis l’IHM d’un fichier FIT avec erreur de commentaire sur la première ligne     Etant donné la première ligne du fichier Fit1.fit ne contenant pas <ligne>     Et le reste du fichier contenant         | [Single/Serial Exposure]   |         | FX128= 1 1 1 70 100 60 100 |     Et un générateur <type>     Lorsque je charge ce fichier depuis l’IHM     Alors j’ai la boîte de dialogue en erreur avec le message: IDS_ERR_LOAD_FIT_FILE_WRONG_HEADER Exemples:     | ligne              | type                           |     | ; TeTriS LWDR file | Philips avec le protocole LWDR |     | ; XSTREAM FIT file | NO                             |     | ; XSTREAM FIT file | philips avec le protocole SDL    |  "));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            Assert.AreEqual(1, extractedRequirements["ESD-TXL-TeTriS-034"].m_Scenarios.Count);

            Assert.AreEqual("Etant donné la première ligne du fichier Fit1.fit ne contenant pas <ligne> Et le reste du fichier contenant | [Single/Serial Exposure] | | FX128= 1 1 1 70 100 60 100 | Et un générateur <type> Lorsque je charge ce fichier depuis l’IHM Alors j’ai la boîte de dialogue en erreur avec le message: IDS_ERR_LOAD_FIT_FILE_WRONG_HEADER Exemples: | ligne | type | | ; TeTriS LWDR file | Philips avec le protocole LWDR | | ; XSTREAM FIT file | NO | | ; XSTREAM FIT file | philips avec le protocole SDL |", extractedRequirements["ESD-TXL-TeTriS-034"].m_Scenarios[0].m_strSteps);
        }

        [TestMethod]
        public void TestExtractIssue8()
        {
            // Arrange
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-036", new Tuple<string, string>("Ouverture d’un document de type FIT [p.153]",
                "Cette fonctionnalité permet d’envoyer un FIT d’un mode donné au générateur de rayons X. L’envoi d’un FIT au générateur permet de paramétrer son fonctionnement. Avec le protocole SDL du générateur philips l’envoi de FIT est synchrone avec la réponse du générateur. Après l’envoi du FIT, une réponse du générateur est attendue pendant cinq secondes. La réponse est interprétée, et en fonction de cette réponse, l’envoi de FIT sera considéré comme réussi ou pas. Si au bout de ces cinq secondes, il n’y a pas eu de réponse alors l’envoi de FIT est considéré comme ayant échoué. Entre l’envoi du FIT et sa réponse, des évènements peuvent être récupérés. Ces évènements ne sont pas considérés comme la réponse du FIT. Avec le protocole LWDR, l’envoi de FIT est synchrone avec la réponse du générateur Après l’envoi du FIT, une réponse du générateur est attendue pendant cinq secondes. Si au bout de ces cinq secondes, il n’y a pas eu de réponse alors l’envoi de FIT est considéré comme ayant échoué. Pour le générateur Siemes, rien n’est fait. Messages de trace générique Trace affichée dans la sortie Générateur : Si le générateur est déconnecté: \" Send Fit Error : X-ray Generator not connected\" S’il n’y a pas de générateur: \" Send Fit Error : No X-ray Generator connected\" Si la connexion est en cours : \" Send Fit Error : wait for X-ray Generator end of connection process\" Si la déconnexion est en cours : \" Send Fit Error : wait for X-ray Generator being disconnected\"   Accès à la fonctionnalité depuis le bouton du document FIT Conditions L’utilisation de fichiers de type FIT n’a de sens qu’avec les générateurs de type PHILIPS. Appui sur le bouton . Résultats attendus Générateur bien connecté : Le FIT est bien envoyé au générateur. La ligne n’apparaît plus sur fond rouge mais sur fond blanc. Générateur non connecté : Une erreur est affichée dans la fenêtre de messages hardware. Message d’erreur Si après l’envoi d’un FIT il n’y a pas de réponse après cinq secondes : \"Send Fit Error : No response from generator\" Si l’envoi échoue : \" Send Fit Error : description\" où description est la description de l’erreur voir annexe.  Accès à la fonctionnalité depuis un script TCL Conditions Un fichier FIT doit être ouvert. L’utilisation de fichiers de type FIT n’a de sens qu’avec les générateurs de type PHILIPS. Syntaxe :  sendFitContin id_Module   sendFitPulsed id_Module   sendFitSingle id_Module Résumé : Ces mots clefs TCL attendent un argument.  Specifications executables  Contexte:     Soit un interpreteur TCL  Scénario: Envoi d’un FIT de type continuous mode à un générateur NO     Etant donné un générateur NO     Lorsque j'appelle le mot clef sendFitContin FX101     Alors j’ai la trace d’erreur numero IDS_GENE_FUNCTION_NOT_AVAILABLE.     Et le script retourne TCL_KO  Scénario: Envoi d’un FIT de type fluoroscopy mode à un générateur NO     Etant donné un générateur NO     Lorsque j'appelle le mot clef sendFitPulsed FX130     Alors j’ai la trace d’erreur numero IDS_GENE_FUNCTION_NOT_AVAILABLE.     Et le script retourne TCL_KO  Scénario: Envoi d’un FIT de type exposure mode à un générateur NO     Etant donné un générateur NO     Lorsque j'appelle le mot clef sendFitSingle FX128     Alors j’ai la trace d’erreur numero IDS_GENE_FUNCTION_NOT_AVAILABLE.     Et le script retourne TCL_KO Résultats attendus Envoi un document FIT vers le générateur X et sortie de la fonction avec TCL_OK Si un problème survient alors un message d’erreur est affiché dans la fenêtre de sortie des messages standards via la fonction TclSetError et le mot clef retourne TCL_ERROR Message d’erreur Si le nombre d’arguments n’est pas le bon : remontée par le TCL du message IDS_ERR_TCL_SEND_FIT_INV_ONE_ARG. Si pas de fichier FIT ouvert : remontée par le TCL du message IDS_ERR_TCL_SEND_FIT_NO_FIT_LOADED. Si l’envoi échoue : remontée par le TCL du message IDS_ERR_TCL_SEND_FIT_ERROR.  Si le FIT n’est pas correct : remontée par le TCL du message IDS_ERR_TCL_SEND_FIT_CONTIN_ID ou IDS_ERR_TCL_SEND_FIT_PULSED_ID ou IDS_ERR_TCL_SEND_FIT_SINGLE_ID. Si après l’envoi d’un FIT il n’y a pas de réponse après cinq secondes : remontée par le TCL du message IDS_NO_RESPONSE. Message de warning Si la fermeture du FIT échoue : « Warning : Could not close fit document nom_document» où nom_document est le fichier fit ouvert.   Accès à la fonctionnalité depuis un script TCL Conditions L’utilisation de fichiers de type FIT n’a de sens qu’avec les générateurs de type PHILIPS. Un fichier FIT doit être ouvert. Syntaxe sendFit id_module id_buffer Résumé : Ce mot clef attend deux arguments, l’identifiant du module à envoyer (CMXXX ou FXXXX) et l’identifiant du buffer de réception.   Specifications executables  Contexte:     Soit un interpreteur TCL   Scénario: Envoi d’un FIT à un générateur NO     Etant donné un générateur NO     Lorsque j'appelle le mot clef sendFit FX101 0     Alors j’ai la trace d’erreur numero IDS_GENE_FUNCTION_NOT_AVAILABLE.     Et le script retourne TCL_KO  Résultats attendus Envoi d’un document FIT vers le générateur X et sortie de la fonction avec TCL_OK. Si un problème survient alors un message d’erreur est affiché dans la fenêtre de sortie des messages standards via la fonction TclSetError et retourne TCL_ERROR.  Message d’erreur Si le nombre d’arguments n’est pas le bon : remontée par le TCL du message IDS_ERR_TCL_SEND_FIT_INV_TWO_ARG. Si pas de fichier FIT ouvert : \" remontée par le TCL du message IDS_ERR_TCL_SEND_FIT_NO_FIT_LOADED.  Si l’envoi échoue : remontée par le TCL du message IDS_ERR_TCL_SEND_FIT_ERROR. Si le FIT n'est pas correct : remontée par le TCL du message IDS_ERR_TCL_SEND_FIT_ID. Si après l'envoi d’un FIT il n'y a pas de réponse après cinq secondes : remontée par le TCL du message IDS_NO_RESPONSE. Si le numéro de buffer dans l'appel de sendFit est incorrect : remontée par le TCL du message IDS_ERR_TCL_SEND_FIT_BUFFER_ID_ERR."));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            Assert.AreEqual("Soit un interpreteur TCL Soit un interpreteur TCL", extractedRequirements["ESD-TXL-TeTriS-036"].m_strContext);
        }

        [TestMethod]
        public void TestExtractIssue10()
        {
            // Arrange
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-067", new Tuple<string, string>("Ouverture d’un document de type FIT [p.153]",
                "Scénario: Etat de l’entrée Detector -> Setup -> DefectMap -> Erase Etant donné un détecteur de type <type>     Et l’etat de connexion du detecteur est <etat>     Alors l’entrée Detector -> Setup -> DefectMap -> Erase est <etat_menu>. Exemple:     | type      | etat       | etat_menu |     | PX4600    | connecte   | actif     |     | PX4700-6  | connecte   | actif     |     | PX4700-2  | connecte   | inactif   |     | PX4700    | connecte   | inactif   |     | PX4800    | connecte   | inactif   |     | gen3      | connecte   | inactif   |     | PX3040    | connecte   | inactif   |     | PX2020C   | connecte   | inactif   |     | PX2121C   | connecte   | inactif   |     | Portable2 | connecte   | inactif   |     | PX2630    | connecte   | actif     |     | PX5100    | connecte   | actif     |     | PX5500    | connecte   | actif     |     | PXFS36    | connecte   | actif     |     | PX4143R   | connecte   | actif     |     | PX4343R   | connecte   | actif     |     | PX4343F-3 | connecte   | actif     |     | materiel  | deconnecte | inactif   |   Messages d’erreur Si l’effacement échoue : \"DefectMap handle n erasing failed\" où n est le handle de la defect map.  Accès à la fonctionnalité depuis un script TCL Conditions Syntaxe :  pxEraseDefectMap {liste d’index} Arguments : {liste d’index}: liste de valeurs indiquant les defect map à effacer. La liste contient les index de la defect map. La liste d’index pour le 4700-6 représente les valeurs de handle de fichier [20-24 ;30-39], alors que pour les autres cette liste représente les index de defect map [0-3]. Pour le 4600 et 5500 l’index de defect map n’a pas de sens. Pour effacer les defectmap de ces derniers il faut utiliser -1 comme index Résumé : Efface les defects map listées. Résultats attendus Efface les defects map contenues dans la liste. Si la liste a pour valeur -1 alors toutes les defects maps sont effacées.       "));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            Assert.AreEqual("Etant donné un détecteur de type <type> Et l’etat de connexion du detecteur est <etat> Alors l’entrée Detector -> Setup -> DefectMap -> Erase est <etat_menu>. Exemple: | type | etat | etat_menu | | PX4600 | connecte | actif | | PX4700-6 | connecte | actif | | PX4700-2 | connecte | inactif | | PX4700 | connecte | inactif | | PX4800 | connecte | inactif | | gen3 | connecte | inactif | | PX3040 | connecte | inactif | | PX2020C | connecte | inactif | | PX2121C | connecte | inactif | | Portable2 | connecte | inactif | | PX2630 | connecte | actif | | PX5100 | connecte | actif | | PX5500 | connecte | actif | | PXFS36 | connecte | actif | | PX4143R | connecte | actif | | PX4343R | connecte | actif | | PX4343F-3 | connecte | actif | | materiel | deconnecte | inactif |", extractedRequirements["ESD-TXL-TeTriS-067"].m_Scenarios[0].m_strSteps);
        }

        //[TestMethod]
        //public void TestExtractIssue11()
        //{
        //    // Arrange
        //    Extractor extractor = new Extractor();
        //    Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
        //    requirements.Add("ESD-TXL-TeTriS-200", new Tuple<string, string>("",
        //        "Description Cette fonctionnalité permet pour tous les types de détecteur de recevoir une image d’offset, ou de X, avec ou sans transmission. Pour les detecteurs 5500, FS36, URF et MMs il est possible de récupérer une image de defect map Pour le détecteur 5500 seulement, il est possible en plus de récupérer une image de correction en température. Il est aussi possible pour le 5500 de récupérer la dernière image prise, pour cela voir l’exigence 188 / accès à la fonctionnalité depuis un script TCL.  Dans le monde 4600 les commandes de récupérations d’image sont envoyées successivement via l’appel des différentes fonctions de l’APIX. Dans le monde 4700 les commandes de récupérations d’image sont celles définies dans le fichier de configuration du profil dans la section FrameRequestSoftwareConfig en fonction du type d’image demandée  Pour le Rad Cr Tdlp, si le type de chrono vaut 3 (dual) 2 images seront récupérées.Si le type de chrono vaut 2 (Séquence) les images sont récupérées en boucle jusqu’ à l’arrêt de l’acquisition. Ces 2 types de chrono ne sont disponibles que pour ce détecteur.     Accès à la fonctionnalité depuis la barre d’outils d’acquisition libre Conditions Pour que la barre d’outils soit accessible il faut que le type de frame trigger soit différent de HARD. Pour obtenir une image, il faut après la sélection, lancer une acquisition libre  Via la barre d’outils d’acquisition libre sélectionner dans le combo box une des entrées disponibles : OFFSET : Image d’offset X : Image de X DM : Image de defect map ICT : Image de correction en température. Ces entrées sont définies dans le fichier de configuration.     Le dernier champ du combo box peut être soit ICT pour une demande d’image de correction en température, soit TRANSMISSION pour la transmission de la dernière image. Si ce champ est différent de ICT ou de TRANSMISSION alors l’image demandée sera une image d’OFFSET.   Résultats attendus Sur un changement de type d’image une trace est affichée dans la sortie standard des messages : FrameRequestSoftwareSetType type successful Changement du type d’image sans RTC     Etant donné un RTC de type NO     Et un interpreteur TCL     Lorsque j'appelle le mot clef frameRequestSoftwareSetType     Alors j'ai la trace d'erreur numero IDS_RTC_FUNCTION_NOT_AVAILABLE     Et le script retourne TCL_KO    Messages d’erreur  Si la demande de changement de type d’image échoue: FrameRequestSoftwareSetType type failed \"Request offset acquisition to detector failed\r\n\" Si la demande d’offset frame échoue: \"Request offset frame to detector failed\r\n\" Si la demande d’image acquisition échoue: \"Request image acquisition to detector failed\r\n\" Si la demande d’image frame échoue: \"Request image frame to detector failed\r\n\" Si la demande de defect map échoue: \"Request defect map image to detector failed\r\n\" Si la demande d’image de correction en température: \"Request image correction temperature to detector failed\r\n\"  Accès à la fonctionnalité depuis un script TCL Conditions Syntaxe : pxRequestImageFrame [X | OFFSET | DM | ICT] {TRUE |FALSE} Résumé : Permet de recevoir une image du détecteur. Paramètre :   Type X : demande une image d’X OFFSET : demande une image d’offset DM : demande une image de defect map ICT : demande une image de correction en température Transmission TRUE : demande de transmission FALSE : pas de demande de transmission  Si la demande de transmission n’est pas définie alors la valeur utilisée par défaut sera en fonction du détecteur. Si le detecteur a des fonctionnalitées de transmission alors la transmission sera demandée, sinon elle ne le sera pas. Pour les demandes de defect map et d’image de correction en température le demande de transmission sera automatiquement mise à FALSE quel que soit le paramètre passé.  Spécifications exécutables  Contexte:     Etant donné un interpreteur TCL   Scénario: Demande d’image avec un detecteur de génération 3     Etant donné un detecteur de generation 3 Et un RTC de type materiel Et une carte d'acquisition type materiel     Lorsque j’appelle le mot clef pxRequestImageFrame <type>     Alors j’ai la trace standard d’information numero <trace>     Et le script retourne TCL_OK Exemples:     | type    | trace                         |     |  X      |                               |      |  OFFSET |                               |     |  DM     | IDS_PXD_FUNCTION_NOT_AVAILABLE |     |  ICT    | IDS_PXD_FUNCTION_NOT_AVAILABLE |  Résultats attendus Récupère l’image demandée : sortie de la fonction avec TCL_OK. Si une erreur survient alors sortie de la fonction TCL_ERROR et stockage de l’erreur via TclSetError. La préparation et l’arrêt du générateur ne sont faits que si un module DIO et un générateur sont présents Messages d’erreur Si le nombre d’arguments n’est pas le bon : \"ERROR pxRequestImageFrame: takes one (\"OFFSET\", \"DM\", \"X\", \"ICT\", \"NO\"), two (\"TRUE\" or \"FALSE\" for transmission ask) or no argument at all (RTC hardware). Si le premier argument n’est pas un de ceux cités plus haut : \"ERROR pxRequestImageFrame: at second parameter : \"OFFSET\" or \"X\" or \"DM\" or \"ICT\" or \"NO\" Si le deuxième argument n’est pas un de ceux cités plus haut : \"ERROR pxRequestImageFrame: at third parameter : \"TRUE\" or \"FALSE\". Si la demande d’offset acquisition échoue: \"Request offset acquisition to detector failed\r\n\" Si la demande d’offset frame échoue: \"Request offset frame to detector failed\r\n\" Si la demande d’image acquisition échoue: \"Request image acquisition to detector failed\r\n\" Si la demande d’image frame échoue: \"Request image frame to detector failed\r\n\" Si la demande de defect map échoue: \"Request defect map image to detector failed\r\n\" Si la demande d’image de correction en température: \"Request image correction temperature to detector failed\r\n\" Si la préparation du générateur échoue alors remontée de l’erreur IDS_RTC_ERR_PREPARE_GENE_FAILED. Si l’arrêt du générateur échoue alors remontée de l’erreur IDS_RTC_ERR_STOP_GENE_TIMEOUT ou IDS_RTC_ERR_STOP_GENE_NO_DIO_MODULE"));

        //    // Act
        //    Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

        //    // Assert
        //    Assert.AreEqual(2, extractedRequirements["ESD-TXL-TeTriS-200"].m_Scenarios.Count);
        //    //Assert.AreEqual("Etant donné un détecteur de type gen3 Et utilisant un frame trigger <type> Alors le type de transmission est <transmission>. Exemple: | type | transmission | | SOFT | FULL | | HARD | NO |", extractedRequirements["ESD-TXL-TeTriS-067"].m_Scenarios[0].m_strSteps);
        //}

        [TestMethod]
        public void TestExtractIssue12()
        {
            // Arrange
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-244", new Tuple<string, string>("",
                "Cette fonctionnalité permet de tracer les données reçues par chaque événement venant du detecteur :  EVT_CODE  SEVERITY  Description     0x0000  0x00  Detector available    0x0001  0x00  Detector not available    0x0002  0x00  BOOT pass. The user application is up and running.      0x0003  0x01  BOOT failed. The user application failed to be started.      0x0004  0x00  LOGIC pass. The user FPGA bit stream is running.      0x0005  0x01  LOGIC failed. The user FPGA bit stream failed to be started.    0x0006  0x00  CONFIG pass. The embedded configuration files are well formed.    0x0007  0x01  CONFIG failed. At least one of the embedded files is not well formed.      0x0008  0x00  POST pass. All the POST succeed.    0x0009  0x01  POST failed. At least one POST failed.    0x000A  0x00  The detector is declared as ready for connection (ONLINE).    0x0100  0x00  Detector Ready    0x200  0x00  Battery to low to perform tbd images    0x201  0x00  Detector entering Listen state    0x202  0x00  Detector entering Off state     CLASS  Description    0x0000  Special « NO ERROR » error code.    0x8100  Hardware error    0x8101  Overheating    0x8102  Battery to low to do an image.    0x8200  Configuration error    0x8300  Internal error    0x8400  Functional error    0x8500  SiS error    0x8600  Protocol error     A chaque événement reçu, la trace associée sera affichée.             Spécifications exécutables  Scénario: Affichage des informations d’un événement détecteur      Etant donné un détecteur de génération 3     Lorsque le détecteur envoie la trame <severite><code><contexte>     Alors j’ai la trace standard d'information <trace>   Exemple :         | severite | code | contexte                                                   | trace |         | 00       | 0001 | 4465746563746F7220726561647920746F20646F20616E20696D616765 | \"Event received : Detector ready to do an image (severity: no, code: 0x100 Detector ready to do an image again )\" |         | 01       | 0900 | 4465746563746F7220726561647920746F20646F20616E20696D616765 | \"Event received : Detector ready to do an image (severity: critical, code: 0x009 POST failed. At least one POST failed ) \" |         | 10       | 0003 | 4465746563746F7220726561647920746F20646F20616E20696D616765 | \"Event received : Detector ready to do an image (severity: warning, code: 0x300 Network reconfiguration request )\" |"));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            //Assert.AreEqual(2, extractedRequirements["ESD-TXL-TeTriS-244"].m_Scenarios.Count);
            Assert.AreEqual("Etant donné un détecteur de génération 3 Lorsque le détecteur envoie la trame <severite><code><contexte> Alors j’ai la trace standard d'information <trace> Exemple : | severite | code | contexte | trace | | 00 | 0001 | 4465746563746F7220726561647920746F20646F20616E20696D616765 | \"Event received : Detector ready to do an image (severity: no, code: 0x100 Detector ready to do an image again )\" | | 01 | 0900 | 4465746563746F7220726561647920746F20646F20616E20696D616765 | \"Event received : Detector ready to do an image (severity: critical, code: 0x009 POST failed. At least one POST failed ) \" | | 10 | 0003 | 4465746563746F7220726561647920746F20646F20616E20696D616765 | \"Event received : Detector ready to do an image (severity: warning, code: 0x300 Network reconfiguration request )\" |", extractedRequirements["ESD-TXL-TeTriS-244"].m_Scenarios[0].m_strSteps);
        }

        [TestMethod]
        public void TestExtractExtractWithMessageAtEndOfScenario()
        {
            // Arrange
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-304", new Tuple<string, string>("",
                " à l’utilisateur dans la sortie des messages standards.  Spécification executable Contexte:     Soit un interpreteur TCL  Scénario: Modification des paramètres de mode     Etant donné un détecteur de génération 3     Et les paramètres de mode définis sont       | nom  |indice | etat |       | mode |  1    | N/A  |       | gain |  2    |      |       | R.L. |  6    |      |       | X.W. |  3    | N/A  |     Lorsque j'appelle le mot clef setModeParameters {{mode 1} {gain 2 N/A} {R.L. 6 N/A} {X.W. 3}}     Alors les paramètres de mode sont       | nom  |indice | etat |       | mode |  1    |      |       | gain |  2    | N/A  |       | R.L. |  6    | N/A  |       | X.W. |  3    |      |     Et le script retourne TCL_OK    Message d’information Si"));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            //Assert.AreEqual(2, extractedRequirements["ESD-TXL-TeTriS-244"].m_Scenarios.Count);
            Assert.AreEqual("Etant donné un détecteur de génération 3 Et les paramètres de mode définis sont | nom | indice | etat | | mode | 1 | N/A | | gain | 2 | | | R.L. | 6 | | | X.W. | 3 | N/A | Lorsque j'appelle le mot clef setModeParameters {{mode 1} {gain 2 N/A} {R.L. 6 N/A} {X.W. 3}} Alors les paramètres de mode sont | nom | indice | etat | | mode | 1 | | | gain | 2 | N/A | | R.L. | 6 | N/A | | X.W. | 3 | | Et le script retourne TCL_OK", extractedRequirements["ESD-TXL-TeTriS-304"].m_Scenarios[0].m_strSteps);
        }



        [TestMethod]
        public void TestExtractExtractWithWordRepeatInTable()
        {
            // Arrange
            Extractor extractor = new Extractor();
            Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-304", new Tuple<string, string>("",
                "Scénario: Définition du type de détecteur     Etant donné le fichier Tetris_Configuration.ini qui définit un détecteur Active Detector et un sous type Active Sub-Detector     Lorsque je cree le detecteur     Alors le detecteur est de type detecteur Exemple:     | Active Detector | Active Sub-Detector | detecteur |     | GEN3            | 2121aSi             | 2121aSi   |     | GEN3            | PX3040              | PX3040    |     | GEN3            | 2020C               | 2020C     |     | GEN3            | 2121C               | 2121C     |     | Gen3            | Portable2           | Portable2 |     | PX3040          | Portable2           | PX3040    |     | PX3040          |                     | PX3040    |     | FS36            | tototo              | FS36      |     | NO              |                     | NO        |     | PORTABLE2       |                     | PORTABLE2 |     | PX_TEST         |                     | PX_TEST   |     | PX2020C         |                     | PX2020C   |     | PX2630          |                     | PX2630    |     | PX3040          |                     | PX3040    |     | PX4143R         |                     | PX4143R   |     | PX4343F-3       |                     | PX4343F-3 |     | PX4343R         |                     | PX4343R   |     | PX4600          |                     | PX4600    |     | PX4700          |                     | PX4700    |     | PX4700-6        |                     | PX4700-6  |     | PX4800          |                     | PX4800    |     | PX5100          |                     | PX5100    |     | PX5500          |                     | PX5500    |     | PX2121C         |                     | PX2020C   |"));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);

            // Assert
            Assert.AreEqual("Etant donné le fichier Tetris_Configuration.ini qui définit un détecteur Active Detector et un sous type Active Sub-Detector Lorsque je cree le detecteur Alors le detecteur est de type detecteur Exemple: | Active Detector | Active Sub-Detector | detecteur | | GEN3 | 2121aSi | 2121aSi | | GEN3 | PX3040 | PX3040 | | GEN3 | 2020C | 2020C | | GEN3 | 2121C | 2121C | | Gen3 | Portable2 | Portable2 | | PX3040 | Portable2 | PX3040 | | PX3040 | | PX3040 | | FS36 | tototo | FS36 | | NO | | NO | | PORTABLE2 | | PORTABLE2 | | PX_TEST | | PX_TEST | | PX2020C | | PX2020C | | PX2630 | | PX2630 | | PX3040 | | PX3040 | | PX4143R | | PX4143R | | PX4343F-3 | | PX4343F-3 | | PX4343R | | PX4343R | | PX4600 | | PX4600 | | PX4700 | | PX4700 | | PX4700-6 | | PX4700-6 | | PX4800 | | PX4800 | | PX5100 | | PX5100 | | PX5500 | | PX5500 | | PX2121C | | PX2020C |", extractedRequirements["ESD-TXL-TeTriS-304"].m_Scenarios[0].m_strSteps);
        }


        [TestMethod]
        public void TestExtractIssue13()
        {
            // Arrange
            Extractor extractor = new Extractor(); Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-046", new Tuple<string, string>("",
                "Description Un mode est une configuration de paramètres pour l'acquisition d'une image, tels que la hauteur, la largeur, la largeur de la bande DRZ, la durée de la fenêtre X, la durée de la fenêtre de backlight et de resetlight, etc.  Les modes peuvent être lus et modifiés depuis l’application. Le mode peut être modifié à tout moment, même en cours d’acquisition.  Spécifications exécutables  Contexte:     Etant donné l’IHM de TeTriS   Scénario: Affichage des modes disponibles     Etant donné la configuration detecteur définissant les modes : | mode | | 1    | | 7    | | 4    | | 3    |     Quand j’affiche le menu <menu>     Alors les modes et leurs informations sont affiches dans l’ordre : | mode | | 1    | | 3    | | 4    | | 7    | Exemple: | menu                             | | Detector->Control->Select Mode   | | mode de la barre de mode         | | mode de la barre de mode etendue |   Suite à un changement de mode toutes les informations du mode sont récupérées via une requête au détecteur. Accès à la fonctionnalité depuis le menu « Detector -> Control -> Select Mode » Conditions Ce sous-menu est actif seulement si un détecteur a été déclaré dans la configuration matérielle (fichier TeTriS_Configuration.ini) et s’il a déjà été connecté et qu’il n’a pas eu de reboot. La liste des modes possibles apparaît. Dans le cas du 4600 et du 5100, seuls les modes dont le chrono est bien programmé sont accessibles. Plus d’informations apparaissent dans ce sous-menu pour chaque mode, comme le nom du chrono, le sens de lecture, le groupe, la taille de l’image avec drz. Résultats attendus Avant d’effectuer le changement de mode, on désactive la correction d’offset quelque soit son type, on réinitialise l’image d’offset de référence. Lors du changement de mode : Si l’on a un RTC Soft et en cours d’acquisition, on prépare le détecteur au changement de mode. C’est le RTC qui le fera en temps utile Sinon on change le mode, on met à jour les informations de la table, du mode et de chrono. La barre d’outil de mode est rafraichie, la fréquence d’acquisition par défaut du mode est mise à jour.  Pour savoir comment sont récupérées les informations voir l’exigence ESD-TXL-TeTriS-254.   Si une erreur survient une trace en informe l’opérateur. Si le changement de mode échoue alors la barre de mode affiche le mode courant et les paramètres associés courants. Aucune demande auprés du détecteur n’est effectuée.  Message d’erreur Dans la sortie des messages standards : Si le détecteur n’est pas configuré : \"Hardware connection disabled \"ERROR: Cannot Switch Mode : description\" où description est la description de l’anomalie.  Dans une boite de dialogue modale : Si un script est en cours d’exécution et que l’on est en profil production: \"Action canceled because a script is running.\"   Accès à la fonctionnalité depuis la barre d’outils de mode ou de mode étendue Conditions Cette barre d’outils présente les paramètres de mode pour tous les détecteurs sauf le 4600. Résultats attendus Avant d’effectuer le changement de mode, on désactive la correction d’offset, on réinitialise l’image d’offset de référence. Lors du changement de mode : Si l’on a un RTC Soft et en cours d’acquisition, on prépare le détecteur au changement de mode. C’est le RTC qui le fera en temps utile Sinon on change le mode, on met à jour les informations de la table, du mode et de chrono. La barre d’outil de mode est rafraichie, la fréquence d’acquisition par défaut du mode est mise à jour.  Pour savoir comment sont récupérées les informations voir l’exigence ESD-TXL-TeTriS-254.   Si une erreur survient une trace en informe l’opérateur. Si le changement de mode échoue alors la barre de mode affiche le mode courant et les paramètres associés courants. Aucune demande auprés du détecteur n’est effectuée.  Message d’erreur Dans la sortie des messages standards : Si le changement de mode échoue : \"ERROR: Cannot Switch Mode : description\" où description est la description de l’anomalie.  Dans une boite de dialogue modale : Si un script est en cours d’exécution et que l’on est en profil production: \"Action canceled because a script is running.\"  Accès à la fonctionnalité depuis un script TCL Syntaxe pxSwitchMode mode   Spécifications exécutables  Contexte:     Etant donné un interpreteur TCL   Scénario: Changement de mode     Etant donné un détecteur de type materiel     Et la configuration detecteur definissant le mode 1     Lorsque j'appelle le mot clef pxSwitchMode 1     Alors le script retourne TCL_OK  Scénario: Changement de mode avec un mode non défini     Etant donné un detecteur type materiel     Et la configuration detecteur ne definissant pas le mode 2     Lorsque j'appelle le mot clef pxSwitchMode 2     Alors j’ai la trace d’erreur numero IDS_TCL_ERR_UNDEFINED_MODE     Et le script retourne TCL_KO  Résultats attendus Changement du mode du détecteur, mise à jour des informations de mode, mise à jour des informations de chrono et rafraichissement de l’interface graphique. Pour savoir comment sont récupérées les informations voir l’exigence ESD-TXL-TeTriS-254.  Si une erreur survient une trace en informe l’opérateur via la sortie des messages standards  Message d’erreur Si le nombre d’arguments est incorrect : \"ERROR pxSwitchMode : one argument required\nUsage : pxSwitchMode mode.\" Si le changement de mode échoue : \"ERROR pxSwitchMode : description\" où description est la description de l’anomalie. Si la mise à jour du mode échoue : \"ERROR pxSwitchMode : cannot Update Mode Information.\" Si la mise à jour des chronos échoue : \"ERROR pxSwitchMode : cannot Update Chrono Information.\""));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);


            // Assert
            Assert.AreEqual("Etant donné la configuration detecteur définissant les modes : | mode | | 1 | | 7 | | 4 | | 3 | Quand j’affiche le menu <menu> Alors les modes et leurs informations sont affiches dans l’ordre : | mode | | 1 | | 3 | | 4 | | 7 | Exemple: | menu | | Detector->Control->Select Mode | | mode de la barre de mode | | mode de la barre de mode etendue |", extractedRequirements["ESD-TXL-TeTriS-046"].m_Scenarios[0].m_strSteps);
        }


        [TestMethod]
        public void TestExtractIssue14()
        {
            // Arrange
            Extractor extractor = new Extractor(); Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-195", new Tuple<string, string>("",
                "Description Elle permet d’afficher les données contenues dans le header d’une image (mode, gain, table etc…) dans une fenêtre d’affichage ancrable et modifiable en taille. Les données affichées sont récupérées du header de l’image définie dans le document TRI 6_08_0635_CDC_astek_Header_Image.doc. Accès à la fonctionnalité depuis le menu view  Spécifications exécutables  Scénario: Configuration des informations de header d’image     Etant donné le fichier Tetris_ImageHeader.ini qui contient les informations suivantes     | clef              | nb_word |   offset   |  masque   | type |     | MODE              |    1    |    0x00    |    0x000F | dec  |     | OFFSET_CORRECTION |    1    |    0x00    |    0x0030 | dec  |     | GAIN              |    1    |    0x01    |    0x0007 | dec  |     | DATA_FORMAT       |    1    |    0x01    |    0x0008 | dec  |     | IMG_WIDTH         |    1    |    0x02    |    0xFFFF | dec  |     | IMG_HEIGHT        |    1    |    0x03    |    0xFFFF | dec  |     | IMG_ORIGIN_X      |    1    |    0x04    |    0xFFFF | dec  |     | IMG_ORIGIN_Y      |    1    |    0x05    |    0xFFFF | dec  |     | XRAYDURL          |    1    |    0x06    |    0xFFFF | dec  |     | BLDUR             |    1    |    0x07    |    0xFFFF | dec  |     | COUNT             |    1    |    0x08    |    0xFFFF | dec  |     | DRZL_W            |    1    |    0x09    |    0x007F | dec  |     | DRZL_H            |    1    |    0x09    |    0x7F00 | dec  |     | DRZR_W            |    1    |    0x0A    |    0x007F | dec  |     | DRZR_H            |    1    |    0x0A    |    0x7F00 | dec  |     | RLDUR1            |    1    |    0x0B    |    0xFFFF | dec  |     | RLDUR2            |    1    |    0x0C    |    0xFFFF | dec  |     | RLDUR3            |    1    |    0x0D    |    0xFFFF | dec  |     | RLDUR4            |    1    |    0x0E    |    0xFFFF | dec  |     | FRAMEFLAG         |    1    |    0x0F    |    0x00FF | bin  |     | TEMP              |    1    |    0x10    |    0x00FF | dec  |     | USERDATA          |    14   |    0x11    |    0xFFFF | hexa |     | SIGNATURE         |    1    |    0x1F    |    0xFFFF | dec  |     Lorsque je reçois une image avec le header suivant     | header |     |010207060b400b40000000001900000000020000000000000000000000000005015b000000000000000000000000000000000000000000000000000000000000010207060b400b40000000001900000000020000000000000000000000000000015b000000000000000000000000000000000000000000000000000000000000010207060b400b40000000001900000000020000000000000000000000000000015b000000000000000000000000000000000000000000000000000000000000|     Alors les données du header sont     | clef              | données    |     | MODE              | 2          |     | OFFSET_CORRECTION | 0          |     | GAIN              | 6          |     | DATA_FORMAT       | 0          |     | IMG_WIDTH         | 2880       |     | IMG_HEIGHT        | 2880       |     | IMG_ORIGIN_X      | 0          |     | IMG_ORIGIN_Y      | 0          |     | XRAYDURL          | 6400       |     | BLDUR             | 0          |     | COUNT             | 2          |     | DRZL_W            | 0          |     | DRZL_H            | 0          |     | DRZR_W            | 0          |     | DRZR_H            | 0          |     | RLDUR1            | 0          |     | RLDUR2            | 0          |     | RLDUR3            | 0          |     | RLDUR4            | 0          |     | FRAMEFLAG         | 101        |     | TEMP              | 91         |     | USERDATA          | 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000   |     | SIGNATURE         | 0000       |  Résultats attendus Affiche les données de la dernière image acquise, sinon la fenêtre reste vide. Les données de la fenêtre seront initialisées en temps réel pendant l’acquisition. Les données affichées dépendront du fichier de configurationErreur   Autres détecteurs : (Tout produit = PX2020C - PX2121C - PX3040 – PX4143R – PX4343R - PX4600 – PX4700 – PX4800 – PX5100 – PX2630 – PX5500 – PXFS36 – PXPortable2-Gen3) Les valeurs sont en décimal sauf contre indication  Titre  Donnée  Produit    Count  Valeur  Tout produit    Table  Valeur ou N.A  PX5100 – PX4143R – PX4343R PX5500 – PX2630 – PXFS36- PX3040- PX2020C – PX2121X – PXPortable2-Gen3    Mode  Valeur  Tout produit    Compression  Valeur  PX5500    Offset Correction  Valeur  PX5500    Gain  Valeur  Tout produit    Xray Window  Valeur  Tout produit    Backlight Duration  Valeur ou N.A  PX5100 – PX2630 - PX4143R – PX4343R - PX2020C – PX2121C – PX3040 – PXPortable2-Gen3    ResetLight Duration  Valeur ou N.A  Valeur ou N.A  Valeur ou N.A  Valeur ou N.A  Tout produit  (pour le PX4700/PX4800, il n’existe qu’une valeur de rldur)    Flag  Valeur en binaire  Tout produit    Width  Valeur  Tout produit-Fichier    Height  Valeur  Tout produit-Fichier    Origin X  Valeur ou N.A  PX5100 – PX5500 – PX2630 – PX2630 - PX4143R – PX4343R - PXFS36 - PX2020C – PX2121C - PX3040 – PXPortable2-Gen3    Origin Y  Valeur ou N.A  PX5100 – PX5500 – PX2630 – PX2630 - PX4143R – PX4343R - PXFS36 – PX2020C – PX2121C - PX3040 – PXPortable2-Gen3    Left Drz Size  Valeur  Tout produit    Top Drz Size  Valeur ou N.A  PX2630 - PX4143R – PX4343R - PX2020C – PX2121C - PX3040 – PXPortable2-Gen3    Right Drz Size  Valeur  Tout produit    Bottom Drz Size  Valeur ou N.A  PX2630 - PX4143R – PX4343R - PX2020C – PX2121C - PX3040 – PXPortable2-Gen3    Detector Temperature 1  Valeur ou N.A  PX2630 - PX4143R – PX4343R - PX2020C – PX2121C - PX3040 –PXPortable2 – PX5500 – PXFS36-Gen3    Detector Temperature 2  Valeur ou N.A  PX5500 – PXFS36    Detector Temperature 3  Valeur ou N.A  PX5500 – PXFS36    User  Valeur en hexadécimal  Tout produit (attention : pas la même taille)    Grid  Valeur  PXPortable2-Gen3    Signature  Valeur ou N.A  PX4700 – PX4800 – PX5100 – PX2630 - PX4143R – PX4343R - PX2020C – PX2121C - PX3040 – PXPortable2-Gen3     Les températures pour le 5500, FS36 et les détecteurs de génération 3 sont calculées de cette manière  Valeur du Header divisée par 10  La température pour le 2630 et 4143R est calculée de cette manière  Valeur du Header divisée par 32  La température est affichée avec une précision d’un chiffre apres la virgule.  L’info bulle pour le champ Flag est « Tablex3 Fr.Typx2 Reord Cut&P NewRun Expos Display Store AcqEn »  Le mode peut prendre les valeurs 0 à 31."));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);


            // Assert
            Assert.AreEqual("Etant donné le fichier Tetris_ImageHeader.ini qui contient les informations suivantes | clef | nb_word | offset | masque | type | | MODE | 1 | 0x00 | 0x000F | dec | | OFFSET_CORRECTION | 1 | 0x00 | 0x0030 | dec | | GAIN | 1 | 0x01 | 0x0007 | dec | | DATA_FORMAT | 1 | 0x01 | 0x0008 | dec | | IMG_WIDTH | 1 | 0x02 | 0xFFFF | dec | | IMG_HEIGHT | 1 | 0x03 | 0xFFFF | dec | | IMG_ORIGIN_X | 1 | 0x04 | 0xFFFF | dec | | IMG_ORIGIN_Y | 1 | 0x05 | 0xFFFF | dec | | XRAYDURL | 1 | 0x06 | 0xFFFF | dec | | BLDUR | 1 | 0x07 | 0xFFFF | dec | | COUNT | 1 | 0x08 | 0xFFFF | dec | | DRZL_W | 1 | 0x09 | 0x007F | dec | | DRZL_H | 1 | 0x09 | 0x7F00 | dec | | DRZR_W | 1 | 0x0A | 0x007F | dec | | DRZR_H | 1 | 0x0A | 0x7F00 | dec | | RLDUR1 | 1 | 0x0B | 0xFFFF | dec | | RLDUR2 | 1 | 0x0C | 0xFFFF | dec | | RLDUR3 | 1 | 0x0D | 0xFFFF | dec | | RLDUR4 | 1 | 0x0E | 0xFFFF | dec | | FRAMEFLAG | 1 | 0x0F | 0x00FF | bin | | TEMP | 1 | 0x10 | 0x00FF | dec | | USERDATA | 14 | 0x11 | 0xFFFF | hexa | | SIGNATURE | 1 | 0x1F | 0xFFFF | dec | Lorsque je reçois une image avec le header suivant | header | | 010207060b400b40000000001900000000020000000000000000000000000005015b000000000000000000000000000000000000000000000000000000000000010207060b400b40000000001900000000020000000000000000000000000000015b000000000000000000000000000000000000000000000000000000000000010207060b400b40000000001900000000020000000000000000000000000000015b000000000000000000000000000000000000000000000000000000000000 | Alors les données du header sont | clef | données | | MODE | 2 | | OFFSET_CORRECTION | 0 | | GAIN | 6 | | DATA_FORMAT | 0 | | IMG_WIDTH | 2880 | | IMG_HEIGHT | 2880 | | IMG_ORIGIN_X | 0 | | IMG_ORIGIN_Y | 0 | | XRAYDURL | 6400 | | BLDUR | 0 | | COUNT | 2 | | DRZL_W | 0 | | DRZL_H | 0 | | DRZR_W | 0 | | DRZR_H | 0 | | RLDUR1 | 0 | | RLDUR2 | 0 | | RLDUR3 | 0 | | RLDUR4 | 0 | | FRAMEFLAG | 101 | | TEMP | 91 | | USERDATA | 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 | | SIGNATURE | 0000 |", extractedRequirements["ESD-TXL-TeTriS-195"].m_Scenarios[0].m_strSteps);
        }




        [TestMethod]
        public void TestExtractIssue14_bis()
        {
            // Arrange
            Extractor extractor = new Extractor(); Dictionary<string, Tuple<string, string>> requirements = new Dictionary<string, Tuple<string, string>>();
            requirements.Add("ESD-TXL-TeTriS-195", new Tuple<string, string>("",
                "Description Elle permet d’afficher les données contenues dans le header d’une image (mode, gain, table etc…) dans une fenêtre d’affichage ancrable et modifiable en taille. Les données affichées sont récupérées du header de l’image définie dans le document TRI 6_08_0635_CDC_astek_Header_Image.doc. Accès à la fonctionnalité depuis le menu view  Spécifications exécutables  Scénario: Configuration des informations de header d’image     Etant donné le fichier Tetris_ImageHeader.ini qui contient les informations suivant     | clef              | nb_word |   offset   |  masque   | type |     | MODE              |    1    |    0x00    |    0x000F | dec  |     | OFFSET_CORRECTION |    1    |    0x00    |    0x0030 | dec  |     | GAIN              |    1    |    0x01    |    0x0007 | dec  |     | DATA_FORMAT       |    1    |    0x01    |    0x0008 | dec  |     | IMG_WIDTH         |    1    |    0x02    |    0xFFFF | dec  |     | IMG_HEIGHT        |    1    |    0x03    |    0xFFFF | dec  |     | IMG_ORIGIN_X      |    1    |    0x04    |    0xFFFF | dec  |     | IMG_ORIGIN_Y      |    1    |    0x05    |    0xFFFF | dec  |     | XRAYDURL          |    1    |    0x06    |    0xFFFF | dec  |     | BLDUR             |    1    |    0x07    |    0xFFFF | dec  |     | COUNT             |    1    |    0x08    |    0xFFFF | dec  |     | DRZL_W            |    1    |    0x09    |    0x007F | dec  |     | DRZL_H            |    1    |    0x09    |    0x7F00 | dec  |     | DRZR_W            |    1    |    0x0A    |    0x007F | dec  |     | DRZR_H            |    1    |    0x0A    |    0x7F00 | dec  |     | RLDUR1            |    1    |    0x0B    |    0xFFFF | dec  |     | RLDUR2            |    1    |    0x0C    |    0xFFFF | dec  |     | RLDUR3            |    1    |    0x0D    |    0xFFFF | dec  |     | RLDUR4            |    1    |    0x0E    |    0xFFFF | dec  |     | FRAMEFLAG         |    1    |    0x0F    |    0x00FF | bin  |     | TEMP              |    1    |    0x10    |    0x00FF | dec  |     | USERDATA          |    14   |    0x11    |    0xFFFF | hexa |     | SIGNATURE         |    1    |    0x1F    |    0xFFFF | dec  |     Lorsque je reçois une image avec le header suivant     | header |     |010207060b400b40000000001900000000020000000000000000000000000005015b000000000000000000000000000000000000000000000000000000000000010207060b400b40000000001900000000020000000000000000000000000000015b000000000000000000000000000000000000000000000000000000000000010207060b400b40000000001900000000020000000000000000000000000000015b000000000000000000000000000000000000000000000000000000000000|     Alors les données du header sont     | clef              | données    |     | MODE              | 2          |     | OFFSET_CORRECTION | 0          |     | GAIN              | 6          |     | DATA_FORMAT       | 0          |     | IMG_WIDTH         | 2880       |     | IMG_HEIGHT        | 2880       |     | IMG_ORIGIN_X      | 0          |     | IMG_ORIGIN_Y      | 0          |     | XRAYDURL          | 6400       |     | BLDUR             | 0          |     | COUNT             | 2          |     | DRZL_W            | 0          |     | DRZL_H            | 0          |     | DRZR_W            | 0          |     | DRZR_H            | 0          |     | RLDUR1            | 0          |     | RLDUR2            | 0          |     | RLDUR3            | 0          |     | RLDUR4            | 0          |     | FRAMEFLAG         | 101        |     | TEMP              | 91         |     | USERDATA          | 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000   |     | SIGNATURE         | 0000       |  Résultats attendus Affiche les données de la dernière image acquise, sinon la fenêtre reste vide. Les données de la fenêtre seront initialisées en temps réel pendant l’acquisition. Les données affichées dépendront du fichier de configurationErreur   Autres détecteurs : (Tout produit = PX2020C - PX2121C - PX3040 – PX4143R – PX4343R - PX4600 – PX4700 – PX4800 – PX5100 – PX2630 – PX5500 – PXFS36 – PXPortable2-Gen3) Les valeurs sont en décimal sauf contre indication  Titre  Donnée  Produit    Count  Valeur  Tout produit    Table  Valeur ou N.A  PX5100 – PX4143R – PX4343R PX5500 – PX2630 – PXFS36- PX3040- PX2020C – PX2121X – PXPortable2-Gen3    Mode  Valeur  Tout produit    Compression  Valeur  PX5500    Offset Correction  Valeur  PX5500    Gain  Valeur  Tout produit    Xray Window  Valeur  Tout produit    Backlight Duration  Valeur ou N.A  PX5100 – PX2630 - PX4143R – PX4343R - PX2020C – PX2121C – PX3040 – PXPortable2-Gen3    ResetLight Duration  Valeur ou N.A  Valeur ou N.A  Valeur ou N.A  Valeur ou N.A  Tout produit  (pour le PX4700/PX4800, il n’existe qu’une valeur de rldur)    Flag  Valeur en binaire  Tout produit    Width  Valeur  Tout produit-Fichier    Height  Valeur  Tout produit-Fichier    Origin X  Valeur ou N.A  PX5100 – PX5500 – PX2630 – PX2630 - PX4143R – PX4343R - PXFS36 - PX2020C – PX2121C - PX3040 – PXPortable2-Gen3    Origin Y  Valeur ou N.A  PX5100 – PX5500 – PX2630 – PX2630 - PX4143R – PX4343R - PXFS36 – PX2020C – PX2121C - PX3040 – PXPortable2-Gen3    Left Drz Size  Valeur  Tout produit    Top Drz Size  Valeur ou N.A  PX2630 - PX4143R – PX4343R - PX2020C – PX2121C - PX3040 – PXPortable2-Gen3    Right Drz Size  Valeur  Tout produit    Bottom Drz Size  Valeur ou N.A  PX2630 - PX4143R – PX4343R - PX2020C – PX2121C - PX3040 – PXPortable2-Gen3    Detector Temperature 1  Valeur ou N.A  PX2630 - PX4143R – PX4343R - PX2020C – PX2121C - PX3040 –PXPortable2 – PX5500 – PXFS36-Gen3    Detector Temperature 2  Valeur ou N.A  PX5500 – PXFS36    Detector Temperature 3  Valeur ou N.A  PX5500 – PXFS36    User  Valeur en hexadécimal  Tout produit (attention : pas la même taille)    Grid  Valeur  PXPortable2-Gen3    Signature  Valeur ou N.A  PX4700 – PX4800 – PX5100 – PX2630 - PX4143R – PX4343R - PX2020C – PX2121C - PX3040 – PXPortable2-Gen3     Les températures pour le 5500, FS36 et les détecteurs de génération 3 sont calculées de cette manière  Valeur du Header divisée par 10  La température pour le 2630 et 4143R est calculée de cette manière  Valeur du Header divisée par 32  La température est affichée avec une précision d’un chiffre apres la virgule.  L’info bulle pour le champ Flag est « Tablex3 Fr.Typx2 Reord Cut&P NewRun Expos Display Store AcqEn »  Le mode peut prendre les valeurs 0 à 31."));

            // Act
            Dictionary<string, Requirement> extractedRequirements = extractor.extract(requirements);


            // Assert
            Assert.AreEqual("Etant donné le fichier Tetris_ImageHeader.ini qui contient les informations suivant | clef | nb_word | offset | masque | type | | MODE | 1 | 0x00 | 0x000F | dec | | OFFSET_CORRECTION | 1 | 0x00 | 0x0030 | dec | | GAIN | 1 | 0x01 | 0x0007 | dec | | DATA_FORMAT | 1 | 0x01 | 0x0008 | dec | | IMG_WIDTH | 1 | 0x02 | 0xFFFF | dec | | IMG_HEIGHT | 1 | 0x03 | 0xFFFF | dec | | IMG_ORIGIN_X | 1 | 0x04 | 0xFFFF | dec | | IMG_ORIGIN_Y | 1 | 0x05 | 0xFFFF | dec | | XRAYDURL | 1 | 0x06 | 0xFFFF | dec | | BLDUR | 1 | 0x07 | 0xFFFF | dec | | COUNT | 1 | 0x08 | 0xFFFF | dec | | DRZL_W | 1 | 0x09 | 0x007F | dec | | DRZL_H | 1 | 0x09 | 0x7F00 | dec | | DRZR_W | 1 | 0x0A | 0x007F | dec | | DRZR_H | 1 | 0x0A | 0x7F00 | dec | | RLDUR1 | 1 | 0x0B | 0xFFFF | dec | | RLDUR2 | 1 | 0x0C | 0xFFFF | dec | | RLDUR3 | 1 | 0x0D | 0xFFFF | dec | | RLDUR4 | 1 | 0x0E | 0xFFFF | dec | | FRAMEFLAG | 1 | 0x0F | 0x00FF | bin | | TEMP | 1 | 0x10 | 0x00FF | dec | | USERDATA | 14 | 0x11 | 0xFFFF | hexa | | SIGNATURE | 1 | 0x1F | 0xFFFF | dec | Lorsque je reçois une image avec le header suivant | header | | 010207060b400b40000000001900000000020000000000000000000000000005015b000000000000000000000000000000000000000000000000000000000000010207060b400b40000000001900000000020000000000000000000000000000015b000000000000000000000000000000000000000000000000000000000000010207060b400b40000000001900000000020000000000000000000000000000015b000000000000000000000000000000000000000000000000000000000000 | Alors les données du header sont | clef | données | | MODE | 2 | | OFFSET_CORRECTION | 0 | | GAIN | 6 | | DATA_FORMAT | 0 | | IMG_WIDTH | 2880 | | IMG_HEIGHT | 2880 | | IMG_ORIGIN_X | 0 | | IMG_ORIGIN_Y | 0 | | XRAYDURL | 6400 | | BLDUR | 0 | | COUNT | 2 | | DRZL_W | 0 | | DRZL_H | 0 | | DRZR_W | 0 | | DRZR_H | 0 | | RLDUR1 | 0 | | RLDUR2 | 0 | | RLDUR3 | 0 | | RLDUR4 | 0 | | FRAMEFLAG | 101 | | TEMP | 91 | | USERDATA | 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 | | SIGNATURE | 0000 |", extractedRequirements["ESD-TXL-TeTriS-195"].m_Scenarios[0].m_strSteps);
        }
    }
}
